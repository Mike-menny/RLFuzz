a = """[{'role': 'system', 'content': 'You are a fuzz driver expert. Write compilable C++ for libFuzzer signature: `extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)`.\n\nRESOURCES:\n- Project headers: {header_name}\n- API summary:\n{context}\n\nREQUIREMENTS:\n- Output must be compilable C++ wrapped in ```cpp```\n- File operations use memory streams'}, {'role': 'user', 'content': 'Generate executable harness:\n1. Chain ≥3 stateful API calls\n2. Derive ALL inputs from `data`/`size`\n3. Use fmemopen() for FILE* operations\n4. Robust error handling for all API calls\n5. Free ALL resources before return\n6. Output files to /workspace/output/project/{project}/work/tem only'}, {'role': 'assistant', 'content': '```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cinttypes>\n#include <cassert>\n#include <iostream>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include "fuzzer/FuzzedDataProvider.h"\n\n// Define your project-specific headers here\n// #include "header_name"\n\nextern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    // Initialize a FuzzedDataProvider to simplify data consumption\n    FuzzedDataProvider provider(data, size);\n\n    try {\n        // Step 1: Chain ≥3 stateful API calls\n        // Example: Assume we have a hypothetical API that requires a file stream and performs operations\n\n        // Create a memory stream from the input data\n        std::unique_ptr<FILE, decltype(&fclose)> mem_stream(fmemopen(const_cast<char*>(reinterpret_cast<const char*>(data)), size, "r"), fclose);\n        if (!mem_stream) {\n            throw std::runtime_error("Failed to create memory stream");\n        }\n\n        // Stateful API call 1: Perform an operation on the memory stream\n        if (!someStatefulApiCall1(mem_stream.get())) {\n            throw std::runtime_error("Stateful API call 1 failed");\n        }\n\n        // Stateful API call 2: Perform another operation on the memory stream\n        if (!someStatefulApiCall2(mem_stream.get())) {\n            throw std::runtime_error("Stateful API call 2 failed");\n        }\n\n        // Stateful API call 3: Perform a final operation on the memory stream\n        if (!someStatefulApiCall3(mem_stream.get())) {\n            throw std::runtime_error("Stateful API call 3 failed");\n        }\n\n        // Step 2: Derive ALL inputs from `data`/`size`\n        // Example: Parse the data to extract parameters for output file name\n        std::string output_file_name = provider.ConsumeRandomLengthString(100);\n\n        // Step 3: Use fmemopen() for FILE* operations\n        // Example: Write output to a file in a specific directory\n        std::string output_path = "/workspace/output/project/{project}/work/tem/" + output_file_name;\n        std::unique_ptr<FILE, decltype(&fclose)> output_file(fopen(output_path.c_str(), "w"), fclose);\n        if (!output_file) {\n            throw std::runtime_error("Failed to open output file");\n        }\n\n        // Write data to the output file\n        if (fwrite(data, 1, size, output_file.get()) != size) {\n            throw std::runtime_error("Failed to write to output file");\n        }\n\n    } catch (const std::exception &e) {\n        std::cerr << "Error: " << e.what() << std::endl;\n        return 1; // Non-zero exit code indicates a failure\n    }\n\n    return 0; // Zero exit code indicates success\n}\n```'}]"""
print(a)